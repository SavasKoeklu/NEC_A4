import random
import tsplib95
from typing import List
from numpy.random import default_rng

from Chromosome import Chromosome
import numpy as np

CROSSOVER_MUTATION_PROB = 0.1
P_TOWER_MUTATION = 0.3
P_INVERSE_MUTATION = 0.3
P_ROTATION_TO_THE_RIGHT_MUTATION = 0.4

P_RANK_SELECTION = 0.2
P_ROULETTE_SELECTION = 0.8

P_ORDER_CROSSOVER = 0.5
P_PARTIALLY_MAPPED_CROSSOVER = 0.5


class GeneticAlgorithm:
    def __init__(self, problem, population_size=200, mutation_rate=0.9, elitism=0.2):
        """
        Initialize the algorithm.
        :param problem: TSP problem to be solved
        :param population_size: size of population on each step
        :param mutation_rate: how many new children will come from mutation
        :param elitism: ratio of individuals surviving after each generation
        """
        self.rng = default_rng()
        self.population_size = population_size
        self.problem = problem
        self.mutation_rate = mutation_rate
        self.surviving = int(elitism * population_size)
        # Crossover can generate only an even number of new individuals. Here we ensure that after some individuals survived,
        # only an even number will have to eb generated by crossover
        if (population_size - self.surviving) % 2 == 1:
            self.surviving += 1
        self.all_populations = []
        self.current_population = None
        self.ranked_probabilities = [x / ((1 + population_size) / 2 * population_size) for x in
                                     range(1, population_size + 1)]
        self.fitness_probabilities = None

    def create_initial_population(self):
        # requirement:
        # Todo: I think we not have to consider asymetric graphs, for example where there is no route between cities or there different distances for (c1,c2), (c2,c1)
        # i think it makes sense that each individual has to be only once in their, therefore when we have a population of 100, with 100 differenct chromosomes
        # the start and the ende node has to be the origin city for each chromosome
        nodes = list(self.problem.get_nodes())
        firstelement = nodes[0]
        nodes.remove(nodes[0])
        population = []
        for i in range(self.population_size):
            while True:
                new_list = nodes.copy()
                random.shuffle(new_list)
                if new_list not in population:
                    break
            new_list.insert(0, firstelement)

            population.append(Chromosome(new_list, self.problem))
        return population

    def use_genetic_algorithm(self):
        # create initial population

        self.current_population = self.create_initial_population()
        self.current_population = sorted(self.current_population, key=lambda chrom: -chrom.fitness)
        self.recalculate_fitness_probabilities()
        self.all_populations.append(self.current_population)

        # TODO: find stationary state, so how much generations? Maybe when the average fitness value get's worse?
        for generation in range(30):
            # The number of best parents automatically go to the next population
            new_population = self.current_population[:self.surviving]
            new_population += self.perform_crossover()
            self.perform_mutations(new_population)
            self.all_populations.append(new_population.copy())
            self.current_population = new_population
            self.current_population.sort(key=lambda chrom: -chrom.fitness)
            self.recalculate_fitness_probabilities()

    def get_selection_function(self):
        p = random.random()
        if p < P_RANK_SELECTION:
            return self.rank_selection
        elif p < P_RANK_SELECTION + P_ROULETTE_SELECTION:
            return self.roulette_selection

        # Should never come here
        assert "Probabilities do not add up to 1"

    def perform_crossover(self) -> List[Chromosome]:
        """
        Perform the crossover process by using different crossover techniques
        :return: List of chromosomes created by a crossover
        """
        children = []
        for i in range((self.population_size - self.surviving) // 2):
            chr1, chr2 = (self.get_selection_function())(2)
            p = random.random()
            if p < P_PARTIALLY_MAPPED_CROSSOVER:
                children += self.one_point_partially_mapped_crossover(chr1, chr2)
            elif p < P_PARTIALLY_MAPPED_CROSSOVER + P_ORDER_CROSSOVER:
                children += self.order_crossover(chr1, chr2)
        return children

    def perform_mutations(self, population) -> None:
        """
        Perform mutations on the given population (inplace by modifying the original list)
        :param population: Population to be mutated
        """
        for i in range(len(population)):
            # Mutate an individual with the certain probability
            if random.random() > self.mutation_rate:
                continue
            # TODO: make more mutations here and a probabilistic decision on which one to use
            mutation_p = random.random()
            if mutation_p < P_TOWER_MUTATION:
                self.tower_mutation(population[i])
            elif mutation_p < P_TOWER_MUTATION + P_INVERSE_MUTATION:
                self.inversion_mutation(population[i])
            elif mutation_p < P_TOWER_MUTATION + P_INVERSE_MUTATION + P_ROTATION_TO_THE_RIGHT_MUTATION:
                self.rotation_to_the_right_mutation(population[i])
            population[i].update_fitness()

    def recalculate_fitness_probabilities(self) -> None:
        """
        The probabilities of each individual to be selected in ranked selection are calculated here only once for each
        population to avoid extra computations.
        Recalculating probabilities based on fitness of individuals
        """
        fitnesses = [c.fitness for c in self.current_population]
        # Very often the fitness here are very low as path lengths are far from zero
        # (e.g. path lengths of 3100 and 3000) would lead to almost the same probabilities for these individuals
        # To avoid this, we rescale the fitness by subtracting the minimum one form each
        s = sum(fitnesses) - min(fitnesses) * len(fitnesses)
        self.fitness_probabilities = [(fitness - min(fitnesses)) / s for fitness in fitnesses]

    def print_population(self, population):
        for c in population:
            print(c.get_as_tuple())

    def evolution_of_minimum(self):
        distances = [[c.get_distance() for c in pop] for pop in self.all_populations]
        min_distances = [min(distance_of_one_population) for distance_of_one_population in distances]
        return min_distances

    # requirements for selection:
    # large fitness large probablity to get selected
    # not too much pressure, so that the space ge's more explored
    def roulette_selection(self, count=1):
        # requirements:
        # select probabilites after fitness of chromosome
        # non negative fitness

        # choose one regarding probabilities
        return list(np.random.choice(self.current_population, count, p=self.fitness_probabilities))

    def rank_selection(self, count=1):
        # requirements
        # Assign ranks by sorting individuals by increasing fitness
        # Probability of selection proportional to rank

        return list(np.random.choice(self.current_population, count, p=self.ranked_probabilities))

    def one_point_partially_mapped_crossover(self, first_chromosome, second_chromosome):
        # requirements
        # Divide both chromosomes at a random position
        # Swap the second half of the chromosomes

        # we want to enforce that two new chromosomes are generated and not that the old ones are coppied
        position = np.random.randint(low=1, high=len(first_chromosome.route) - 1)

        new_first_route = first_chromosome.route.copy()
        new_second_route = second_chromosome.route.copy()
        # switch cities in poisition i for new routes from parent routes
        for i in range(position):

            # if element is not already at the same place
            if new_first_route[i] != second_chromosome.route[i]:
                firstroute_index_for_current_element = new_first_route.index(second_chromosome.route[i])
                # put element to replace on the index where element which replaces is
                new_first_route[firstroute_index_for_current_element] = new_first_route[i]
                # replace 
                new_first_route[i] = second_chromosome.route[i]

            # same for b
            secondroute_index_for_current_element = new_second_route.index(first_chromosome.route[i])
            if i != secondroute_index_for_current_element:
                new_second_route[secondroute_index_for_current_element] = new_second_route[i]
                new_second_route[i] = first_chromosome.route[i]

        # create two new chromosomes with route
        first = Chromosome(new_first_route, self.problem)
        second = Chromosome(new_second_route, self.problem)

        return [first, second]

    def order_crossover(self, first_chromosome: Chromosome, second_chromosome: Chromosome):
        def order_chromosome_create_child(parent_main: Chromosome, parent_secondary: Chromosome, pos1,
                                          pos2) -> Chromosome:
            # Create a child chromosome with the same route as the main parent
            child = Chromosome(parent_main.route.copy(), parent_main.problem)

            # We keep the part of the chromosome between the two selected positions,
            # but nodes on all the replace_indices will be reordered
            replace_indices = list(range(pos1, pos2)) if pos2 > pos1 else list(range(0, pos2)) + list(
                range(pos1, len(parent_main.route)))

            # Select specific nodes that will be reordered into a set
            nodes_to_reorder = {parent_main.route[i] for i in replace_indices}

            # Reorder the nodes_to_reorder into the same order as in the secondary chromosome
            nodes_ordered = [parent_secondary.route[i] for i in range(len(parent_main.route)) if
                             parent_secondary.route[i] in nodes_to_reorder]

            for i in range(len(replace_indices)):
                child.route[replace_indices[i]] = nodes_ordered[i]
            child.update_fitness()
            return child

        p1, p2 = self.rng.choice(len(first_chromosome.route), size=2, replace=False)
        return order_chromosome_create_child(first_chromosome, second_chromosome, p1, p2), \
            order_chromosome_create_child(second_chromosome, first_chromosome, p1, p2),

    @staticmethod
    def tower_mutation(chrom):
        positions = random.sample(range(len(chrom.route)), 2)
        chrom.route_swap_positions(positions[0], positions[1])

    @staticmethod
    def inversion_mutation(chrom):
        p1, p2 = random.sample(range(len(chrom.route)), 2)
        # Here the route is a "cyclic" array, so the first index goes after the last one
        # When performing inverse it's important to not prioritize inverses in the center of array over ones
        # on the edges
        if p1 < p2:
            # A normal inverse in the middle of a chromosome
            chrom.route[p1:p2] = chrom.route[p1:p2][::-1]
        else:
            # The segment that need to be inverse goes "over the edge" of the array
            # I use the property of array being cyclic to perform the inverse

            # Firstly, inverse the middle part
            chrom.route[p2:p1] = chrom.route[p2:p1][::-1]
            # Then, inverse the whole route to keep the middle part back in initial order
            chrom.route = chrom.route[::-1]

    @staticmethod
    def rotation_to_the_right_mutation(chrom):
        shift_right = lambda arr, n: arr[len(arr) - n:] + arr[:len(arr) - n]
        p1, p2 = random.sample(range(len(chrom.route)), 2)
        if p1 < p2:
            k = random.randint(1, p2 - p1)
            chrom.route[p1:p2] = shift_right(chrom.route[p1:p2], k)
        else:
            # If the chosen chunk goes "over" the edge
            # Perform a simple shift of the whole array that does not influence the solution
            chrom.route = chrom.route[p2:] + chrom.route[:p2]
            shift_chunk_size = len(chrom.route) - (p1 - p2)
            k = random.randint(1, shift_chunk_size)
            chrom.route[0:shift_chunk_size] = shift_right(chrom.route[0:shift_chunk_size], k)
            # Perform the shift back to the left to keep the not altered part on the same place
            chrom.route = chrom.route[len(chrom.route) - p2:] + chrom.route[:len(chrom.route) - p2]


if __name__ == '__main__':
    problem = tsplib95.load('datasets/gr17.tsp.txt')
    Alg = GeneticAlgorithm(problem, 200)

    Alg.use_genetic_algorithm()
    # for pop in Alg.all_populations:
    #     print("new population")
    #     Alg.print_population(pop)

    print(Alg.evolution_of_minimum())

# a = [5,7,1,3,6,4,2]
# b = [4,6,2,7,3,1,5]
# position = np.random.randint(low=1,high=(len(a)-1))
# # switch the first half
# new_a = a.copy()
# new_b = b.copy()
# print(f"position: {position}")


# for i in range(position):
#     a_index_for_current_element = new_a.index(b[i])
#     # if element is not already at the same place
#     if new_a[i] != b[i]:
#         # put element to replace on the index where element which replaces is
#         new_a[a_index_for_current_element] = new_a[i]
#         # replace 
#         new_a[i] = b[i]

#     # same for b
#     b_index_for_current_element = new_b.index(a[i])
#     if i != b_index_for_current_element:
#         new_b[b_index_for_current_element] = new_b[i]
#         new_b[i] = a[i]


# print(new_a)
# print(new_b)
